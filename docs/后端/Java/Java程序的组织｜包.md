# Java程序的组织

> 第一章提到过，Java程序编写在`.java`文件中，称为源文件；第二章介绍了Java是由一个个类组成的。这一章主要介绍他们之间的关系、以及构成Java程序的多个类如何存放。

## 源文件、类、主类、包

`.java`源文件，是Java程序最基本的编译单元，将一个个代码文件编译为对应的`.class`文件后执行。

类存放在源文件中，一个Java源文件内，只能有一个类型为public的公共类(也可以没有)，作为运行该源文件、通过该源文件启动程序时的的入口。这个类的名字，必须和源文件名相同。这个类称为该源文件的主类。

一个Java源文件可以有很多个类，但最多只能有一个主类。不过一般而言，多数时候，都习惯用一个类对应一个源文件，文件名和类名相同。但也有很多时候：几个类关系非常紧密、构成从属关系时、与其他类再无瓜葛，也会在一个源文件放多个类。

在类之上还有包，Java使用包将类组织在一个集合中，借助包来方便地组织代码，将自己的代码与别人提供的代码库、将负责某一个功能的代码与负责其他工作的代码分开管理。

## 包名

除了从语义上将不同功能的代码划分，使用包的另一主要原因是确保类名的唯一性。

不同的代码编写者可能建立了同样名字的类，毕竟他们各自的所实现的功能可能都包含某一类服务该功能的类，名字是很容易重复的。

将类放置在不同的包里，就能解决这一冲突。包起到了分隔命名空间的作用。

不过显然，包的名称，和包内类的名称，都需要保持唯一性。为了保证包名的绝对唯一性，通常用一个英特网域名的逆序形式作为包名。

- 从大到小：固定的前缀`com`➡️组织名➡️组织内细分名称➡️工程名➡️工程内细分功能模块名。
- 用英文句号`.`将每一层级分开。
- 类的名字首字母大写，而包名的首字母都小写。对于多个单词，一般也采用驼峰命名。
- 例如：`com.wml.demo`。

如果把类放在包里，用包名作为这个类的前缀，例如`com.wml.demo.Util`，这个名字就是类的**完全限定名**。

## 包的创建

- **与文件目录映射**

	Java中包的组织结构，和文件系统中目录的结构是一样的。

	包是通过文件夹来建立的，或者说文件夹为包的载体，一个文件夹就是一个包，文件夹内包含多个Java源文件，文件夹内这些源文件、源文件中的类都属于这个包。

	包名是多个层级用句号分隔组成的，每个层级对应一个文件夹，即每一层都相当于是一个包。

	也就是说包是可以嵌套的，每一层文件夹的名字，就是这一层级的名字。从根位置到当前位置，每一层文件夹名字组成了当前这个文件夹包的包名。

	包虽然可以嵌套，但嵌套的包之间不存在任何（从属）关系，它们各是各的层级，没有任何联系，不存在某个包属于另一个包、是另外一个包的子包这种说法。
	<br>也不存在访问权限上的从属，名称的访问权限只按照上一章访问权限修饰符中介绍的规则来划分。
	<br>例如`java.util`与`java.util.jar`两个包毫无联系，每个包都是一个独立的类集合。

- **声明包**

	上面只是必要条件，也就是说放在类对应目录下也不简单属于这个包，但如果属于这个包，就必须放在这个位置，因为Java查找类的时候是根据这个查找的。
	
	除了放在正确的位置，还要在源文件的第一行最开始，声明它所属的包，语法为`package 包名;`。
	
	如果没有这个语句，源文件里的类就属于一个默认的**无名包**。

## 包的导入——使用其他包中的类

前面访问权限修饰符介绍过，一个类可以使用它所属包中的所有其他类，以及其他包中的公共类。

在一个类中访问另一个包中的public类有两种方法：

1.使用该类的完全限定名，即`包名.类名`。

2.但这样比较繁琐，更简单常用的方式是使用import语句。

语法为：`import 包名.*;`。该语句表示导入这个包下的所有公共类，这之后可以直接使用相应类名。

- import语句必须放在源文件的一开始，在开始的位置导入所有需要的类，不能穿插别的代码。
- 前面提到过，以另一个包名为前缀的包，它们之间没有任何关系，导入也是同理，上面的语句只是导入这个包自己的类，并不会导入以该名字为前缀的其他包内的类。
- 还可以通过语句`import 包名.类名;`，明确地只导入专门的类。
- 几个包导入的类中存在同名类时：
	- 在类名前面加上包名来使用，通过类的完全限定名来区分。
	- 也可以通过在导入的类名后面加`as 别名`，通过使用别名区分。

>前面讲到过，Java源文件只能有一个和文件名相同的公共类，而导入其他包的类的时候也只能导入公共类，所以非常巧，导入类时的这个名字，恰好也是源文件的名字，像是导入了这个源文件一样（但其实不是，这个文件内的其他非公共类并不能使用）。


**静态导入：**
除了上面三种方式，还有一种import语句，用于导入某个类的全部静态成员，语法为：`import static 包名.类名.*;`，这样可以导入这个类下的全部公共成员，能够直接使用它们的名字。
<br>除此之外，也可以专门导入某个特定的静态成员，语法和前面相似。

## classpath 类路径（其实叫包路径更贴切）

**基本概念：**

上面讲的是通过包来唯一确定类、如何在包中定位类，那么要怎么定位包呢？

通过指定类路径，来告诉JVM，运行一个Java程序时，在什么位置找到包含着类的包。

**指定classpath的方式有两种：**

- 通过java或javac命令运行Java程序时，通过-classpath选项来指定类路径，语法为在命令后添加选项`-classpath 类路径`。
- 在操作系统设置全局变量。全局变量的概念第一章有提到过，具体设置方式Window系统和UNIX系统有差异，可自行搜索。

>一般采用后者，为所有Java程序，设定一个通用的、永久不变的classpath不是一个好的做法，因为人们经常会忘记全局设置。
>
>在每次调用命令时，通过选项设置classpath更优。但这样做比较麻烦，最佳实践是：将每个需要设置类路径的Java程序的那个很长的编译、运行指令，存放在一个shell脚本或者批处理文件中，每次直接运行这个脚本。

**寻找某个类的过程：**

当你编译或运行Java程序时，如果是Java API提供的类，则不需要任何classpath就能直接使用；
<br>如果在运行命令时指定类classpath，就会按照你指定的路径挨个寻找包、寻找包中的匹配名字的类；
<br>如果没有指定选择，则会去系统全局变量中找，按照全局变量配置的classpath来搜寻类。

Java开发环境在寻找类时，总会先去java.lang寻找。这个包是默认导入，默认导入到了所有源文件，无需导入可以直接使用。然后再去根据你所声明的导入，按照上面的规则去搜索类。

**完全限定类名必须唯一：**

根据classpath搜索类时，会在每一个路径下，都按照包路径去查找一遍，尽管在某个路径下已经找到了。如果找到一个以上的类，就会报错，因为完全限定类名必须为一。不能存在两个一样的包装着一样的类。

**classpath的格式/语法：**

- 类路径可以有多个，Windows环境中用分号`;`分隔，UNIX环境用冒号`:`
- 句点`.`表示的是当前所在位置/目录。它可以单独作为路径加入classpath表示运行指令时所在的当前路径，例如：`/home/userX/dir1:.:/home/userY/dir3`，这里面包含了三个路径，中间那个就是表示当前位置的相对路径。当前目录是需要显式指定的：
	- 如果进行编译指令，编译器会自动把当前执行命令时的所在目录也纳入类路径，自动去当前目录下搜索包。
	- 但对于运行Java程序的指令，如果你没有显式指定当前目录，又使用了当前目录下某个包的类，Java解释器是不会自动搜寻的，会因找不到这个类而报错。

classpath所指定的是包树状结构的基目录：即类路径是存包的，而不是包的根目录，包的根目录是放在classpath这个路径对应的目录里面的。

## JAR文件

> 根据前面所介绍的，通过包来组织Java程序，然后一个个包实际上就是一个个文件夹，使用者把这些文件夹存放在合适的位置之后，配置classpath，然后编译、运行程序。
> 
> 在这样的工作流中，当时人们存在这样一个需求：希望将这些程序作为一个整体对使用者/外部发布，并且优化传输效率/压缩体积。
> 
>JAR就是为了解决这一需求产生的：只向用户提供一个单独的文件，而不是一个包含大量类文件的目录结构。
>
>除此之外，它的使用还有利于版本控制，可以包含有关它内部文件的一些信息，以及厂商、版本等信息。

全称Java Archive，Java归档文件。它的本质是一个ZIP压缩文件：

- 就是把你用来创建包的文件夹通过ZIP压缩格式压缩；
- 这里面既可以包含类文件，也可以有图像、影音等文件；
- 然后附上这个包的一些描述信息（一个manifest的清单文件，也可以没有）；
- 最后把压缩文件后缀设置为`.jar`。

**用途上，依旧是Java包：**
通过压缩并加上jar后缀之后，Java的一些工具，就能够将其识别为jar文件，从而进行相关操作。因为它的本质就是对Java程序包的压缩，所以使用起来和Java包是一样的，怎么通过classpath使用包的，就用同样的方式使用JAR文件，Java环境里的工具会自动识别并拿到压缩文档里的内容。

- 配置classpath的时候，路径可以直接指向JAR文件。
- 除此之外还可以指向一个目录下的所有文件，通过`/*`表示，意味这个目录下的全部JAR文件。注意UNIX系统的“*”需要转义，防止扩展。

**可以直接打包源文件，也可以是目标文件：**
包的话一般都是`.java`源代码，不过JAR文件里是什么都行，你可以是直接打包源文件，也可以把代码都编译好了再打包，具体看使用习惯。反正用这个包的人，都要有编译这一步，他的代码要是引用了这个包的内容，没编译会跟着一起编译的。

### 创建JAR

因为它的本质就是ZIP，所以你既可以用Java环境中的工具，通过命令来基于一个文件夹创建JAR；也可以给一个文件夹加上manifest描述文件(如果有需要的话)后，直接压缩成ZIP文件，然后把后缀改成jar。这两者的效果是一样的。下面主要介绍怎么通过命令创建。

使用jar工具创建JAR文件，在默认的JDK安装中，位于jdk/bin目录下。**命令的格式**是：`jar option jarFileName params1 params2 ...`。

jarFileName是要生成或操作(这取决于option中的操作)的JAR文件名；option是一个组合式命令，风格类似于UNIX tar 命令。

这是一个用于创建和解压缩归档文件的命令行工具，广泛用于 Linux 和 Unix 系统。将一系列的操作，拆分抽象成一些最基本的命令单元，使用这些命令单元的字母代号，通过将它们拼接在一起，来表达一个操作。然后在这个命令组合的后面就是一些列参数，这些参数的顺序很乱，几乎和前面的选项没什么对应关系而言，这个关系具体是怎样的，看下面的例子吧。参数的顺序没规则可言，反正选项的组合就那么几种，参数的顺序你可以背下来，也可以忘了去搜。

jar命令大致上遵循了这个格式，搞清楚了命令代码的含义，就清楚了如何使用jar，下面的对照表，就是对各个选项的说明，这些选项理解起来可能会很晦涩，所以在后面附带了几个例子。

| 选项   | 说明 |
| :-----------: | ----------- |
| c      | 创建JAR       |
| t   |显示JAR中的内容列表        |
|x	|解压jar，恢复成文件夹|
|u	|向JAR包里追加文件|
|v	|生成操作报告，输出到标准设备（例如你敲命令的控制台）|
|m	|指定manifest.mf文件（前文提到过，就是一个描述JAR的文件，后面会展开解释）|
|M	|创建时不产生manifest.mf文件|
|0	|只是单纯的创建JAR，但不压缩。（是数字不是字母O）|
|i	|建立索引文件|
|f	|指定JAR的文件名，文件名作为第二个参数(第一个参数是这些命令选项的组合)。如果不加这个指令参数，如果是创建JAR，就会自行拟定一个名称，将结果写至标准输出；如果是解压或者读取，就会提示并通过标准输入读取，让你补一个。|
|e	|指定JAR的主类/入口文件，这一点下面会详细展开。|
|C	|改变执行当前指令的位置，在指定的路径下执行指令。|

这些个命令里，ctxu是必须且只能选一个的（因为互斥），剩下的选项是可选选项。ctxu决定了指令的大方向、主要做什么，可选项多是描述要怎么做、是否需要施加一些额外影响。

1. 示例一：创建一个最简单的JAR文件
	
	`jar cvf MyApp.jar *.class`
	
	这将把当前位置下的所有 .class 文件打包到名为 MyApp.jar 的 JAR 文件中。
	
	这其中MyApp.jar就是选项f对应的参数。后面要打包内容的路径就是选项c的参数。
	
	参数顺序没和选项顺序一致：前面f的说明讲过，包名这个参数必须位于第二位，在所有其他参数前。
	
	可以看到，要打包的文件路径可以包含通配符。
	
2. **注意：jar打包是会包含后面给出要打包文件的目录结构的。**示例二：比如你只是要打包目录code下名为comX和comY的两个包，不想要code这个目录。但如果你执行的代码是`jar cvf Demo.jar code/*`，最终得到的JAR文件会把目录结构也加进去，JAR进去里面先是code，再进去才的这两个包。

	所以为了避免这种结果，你就得先把命令行的位置切到code目录下，
	<br>或者⬇️下面例十里的`-C`选项的作用之一，就是解决这样的问题。

	
3. 示例三：显示JAR包内容列表

	`jar tvf hello.jar`

	这将显示 hello.jar 包中的文件列表。
	
4. 示例四：解压JAR包

	`jar xvf hello.jar`
	
	解压该包到当前目录。
	
5. 示例五：向 JAR 包中添加文件

	`jar uf hello.jar HelloWorld.java`

	命令将 HelloWorld.java 添加到 hello.jar 包中。

6. 示例六：**JAR包内可以不只有一层，内部可以是一个目录**。将文件追加到JAR的特定层级。

	就是说，你可以把一个多层嵌套的目录（也对应着多个包）打包成一个JAR文件，目录的层级依然存在，这里面依旧是多个包，你甚至还可以把存放着多个包的根目录的位置，按照示例一里那样通配符的方式，将多个包打包进一个JAR里。
	
	示例四中是往JAR里追加文件的最简形式，直接放在了JAR内第一层目录下。如果你希望将某个文件追加到JAR某一层的话，有两种方法：
	- 先解包，放进去之后再重新生成JAR。
	- 追加这个文件时，文件路径中，文件的名字前面加上包名。例如：`jar uf hello.jar com.mycompany.mypkg.HelloWorld`，追加文件的时候就会先按照路径找到文件，然后再按照包的名称从JAR中找到对应层级，加入这个文件。
		
		>这个写法的正确性存疑，我也是在网上看到的，不确定。我的疑惑在于，那我要追加的文件不是类怎么办，我如果想追加class或者图片之类的呢？
	
7. 示例七：创建带有 manifest.mf 文件的 JAR包。

	`jar cvfm hello.jar MANIFEST.MF hello`
	
	在 JAR 包中生成一个 META-INF 目录，其中包含一个MANIFEST.MF文件。有关这个目录和文件，后文会展开说明。
	
	m是指定一个描述文件，M是不指定，也就是说你这俩都不写的情况下，也会默认生成一个描述文件。
	
	选项m的用途是专门指定一个你自己写的文件来充当。并且当然，你自己写的这个描述文件不非要叫manifest.mf，可以是别的什么mf，不然这后面也就不需要一个专门的参数来标识你所指定的这个文件了。你可以随便写，但jar只认manifest，最终生成的JAR里，描述文件的名字都会是manifest，不过取了你指定文件里的内容。
	
	需要注意这里参数的顺序，顺序很乱，和前面选项是对应不上的。
	
8. 示例八：为已有的manifest文件追加内容

	`jar ufm MyArchive.jar mfAdditions.mf`
	
	只需要把要追加的内容写在这个文件里，jar命令就会自动提取追加在旧文件内容的后面。
	
	所以如果你是希望修改就描述文件，就得解包修改再生成，或者重新指定了。
	
9. 示例九：为 JAR 文件创建索引列表

	`jar i hello.jar`
	
	为指定的 JAR 文件生成索引文件，在 JAR包的 META-INF 文件夹下生成一个名为 INDEX.LIST 的索引文件。这样能在JAR内文件比较多时候，方便文件检索。
	
	上面示例可以看到：这个选项能单独使用。
	
10. 示例十：改变命令执行的位置。

	`jar cvfm -C hello/ hello.jar mymanifest.mf`
	
	这个命令的效果就是基于当前所在的相对位置，找到当前位置的hello目录进入，然后在这个位置执行创建JAR的命令。
	
### 清单文件

除了类、图像和其他资源外，JAR文件还可以包含一个其特有的清单文件，用来描述归档文件的特殊特性。

位于JAR内一个特殊的META-INFO子目录中。

符合标准的最简清单文件只有一行：
`Manifest-Version: 1.0`，描述了JAR的版本信息。

复杂的清单文件可以包含更多条目，这些条目通过空行被分为许多节，第一节称为主节，描述作用于整个JAR文件。随后的条目用来指定包内各命名实体的属性，例如某个文件、包或者URL，每个条目必须以NAME开始，冒号后要有一个空格，然后实体的名称，换行后写对该实体的描述，描述不能主动换行。

注意：空格、换行都不能少也不能多。1.NAME:后有且只能有一个空格；2.节与节之间用空行分隔；3.描述和Name之间要换行；4.不能有多余的空格；5.描述文件必须以换行符结尾，即在最后一行敲个回车，换到一个空行。

示例：

```MANIFEST
Manifest-Version: 1.0
lines describing this archive

Name: Test.class
lines describing this file
Name: com/mycompany/mypkg/
lines describing this pkg
```
清单文件里还能写很多别的内容，这是些最基本的，具体可以查阅官方文档了解。

### 可执行JAR文件/JAR文件的入口

前面讲类的时候，说类需要一个用于执行时的入口，JAR文件也是可以被执行的，需要为他指定一个执行时的入口类。这样一来运行该JAR文件时，入口类的入口——main方法会被执行。

**设置入口的两种方式：**

- 通过选项e指定，后面参数要跟这个类的名字（完全限定名）。<br>e选项可以与多个选项组合，既可以是创建JAR时指定入口，也可以是追加一个文件同时将其设置为入口。
- 通过在清单文件的主节内包含条目`Main-Class:`。

	>注意这个主类的名字不要加扩展名`.class	`。

**执行JAR的两种方式：**

- 对于配置了入口的JAR文件，可以通过命令`java -jar ArchiveName.jar`来启动。
- Windows系统中为.jar后缀的文件创建了关联后可以直接点击运行，MacOS则可以直接点击运行。

	>Windows平台中还可以使用第三方包装器工具，将jar转换为Windows可执行文件，例如Launch4J和IzPack。
	
### 多版本JAR文件（multi-release JAR）

**背景：**
思考这样一种情形，你的代码从Java8版本迁移到Java9，代码中用到了一个Java8的某个内部类，在Java9被移除、替换为了别的类，这种情况下你就需要更改代码。但问题是使用你代码的人又可能使用Java8环境，也用可能是9。多版本JAR文件就是用于这种情况，力图在只提供一个版本的JAR文件的情况下，向后兼容多个版本的JDK。

**注意：**
这一特性的唯一目的你某个特定版本的程序或库能在多个不同版本的JDK上运行，如果你增加了个新的功能、改变了API，就是一个全新的版本，应当提供一个新版本的JAR。

**创建多版本JAR文件：**
创建的方式和你创建普通JAR基本一致。首先编写的时候，编写多个JDK版本的程序或库，把适用于多个版本的JDK的包分别存放在不同的目录、编译。然后对他们打包，在之前创建JAR命令的基础上，在命令的后面加上`--release`标志，这个标志就是用于标识某个特定版本的，后面跟两个参数，第一个参数是要兼容的JDK版本号，第二个参数就是所适配该版本的用于制作JAR的包的路径。因为两个版本的包放在了不同的路径，所以还要用`-C`选项支出包所在的位置。

例：
<br>项目为demo，项目分别有两个版本，一个是默认的Java8，以及特别适配的Java9。将本来的代码书写编译到demo/bin/8/com/mycompany/mypkg/Test.class，那么为Java9适配的代码就是改动并编译后放在demo/bin/9/com/mycompany/mypkg/Test.class。
<br>在demo这一级输入命令`jar cf Demo.jar -C bin/8 . --release 9 -C bin/9 .`。
<br>这一命令的前半部分和前文介绍的创建JAR命令是一致的，就是将路径切换到./bin/8下，取这里面的文件生成名为Demo.jar的文件。
<br>命令后半部分的含义是再把路径切到./bin/9下面取里面的所有文件，将其作为用于适配Java9的内容加入JAR文件。

**实现机制/效果：**
这种用来保证向后兼容的操作，是通过META-INFO中的额外文件实现的，执行上面那样的创建操作，jar首先会在MANIFEST.MF描述文件的主节中加入条目`Multi-release: true`，同时自动在JAR包的META-INFO下面加入你指定用于向后兼容的文件。
<br>它会自动比对，把和默认版本不同的地方的文件，放到这个位置。具体的结构是在这个目录下面创建一个名为versions的文件夹，再在这个文件夹下创建名为你所指定的JDK版本号的目录，把为这个版本特别适配的文件放在这里面。

按照上面的例子，打包过后的META-INFO目录下的内容长这样：

```
META-INFO
｜- MANIFEST.MF (with line Multi-release: true)
｜- versions
	｜- 9
		｜-Test.class
```

**使用：**
这种JAR文件的使用和前面没什么不同，该怎么用怎么用就好了，它会根据俄调用处的JDK环境自动适配。比如说这个JAR包为Java9做了向后兼容，那么JVM就会去匹配，看有没有与环境版本匹配的兼容版本，要是没有就直接按照默认的包执行了，要是有则会用对应版本的内容替换掉默认的。

>但反编译工具javap命令并不能处理多版本文件，如果你调用这个命令反编译JAR内的某个class文件，最终得到的java文件只会是基础版本的。要是你想查看更新兼容版本的源代码，则需要指示路径，指示寻找这个高版本兼容文件的路径。
>
>例如：`javap -classpath MyProject.jar\!/META-INF/versions/9/Test.class`。
><br>相当于是直接指定类要反编译文件的路径了，这个例子是我在Java Core书上看到的，我其实并不理解这里面`\!`是干嘛的，网上啥信息都找不到，我猜是用于分隔包路径和类路径的，前半部分是classpath找包的，后面是指定包内类位置的。
>
>但其实更好的做法是直接用jad工具，是一个功能更强大且易于使用的反编译工具，支持多版本 JAR 文件的反编译。

**在编译时，编译为用于打包的指定JDK版本的目标文件：** 
编译的时候也可以用前面的那个`--release`标识来指定要编译的版本，还是在这个标志后面加版本号。用`-d`指示编译后的输出目录（，目录如果不存在会先创建再输出）。例如：`javac -d bin/8 --release 8 要编译的内容`，这样对应的代码就会被编译为适用于JDK8版本的目标文件，输出到目录./bin/8。

**追加文件和创建JAR是同样的写法：**
还是用前文介绍的那种命令给JAR包追加文件，要追加的文件如果是用于某个特定向后兼容版本的，还是在这个文件前添加选项`-release 目标版本`。

**追加新的兼容版本：**
如果你创建的时候，只做了Java9的向后兼容，之后又想加个Java11的，那么因为已经有了JAR文件，用来兼容Java11的这些新文件理应属于追加文件的范畴，所以也是用上面的操作。
<br>当然，你还可以先解包，然后重新打包。

## 模块

在包的上面还有模块，这部分内容将在后面介绍。

## 总结

按照级别由小到大，Java程序是这样组成的：

语句 -> 

类（包含属性、代码块、入口）->

包（内部可能还会嵌套若干个不构成所属关系的其他包） ->

JAR（本质也是包、有入口）->

模块