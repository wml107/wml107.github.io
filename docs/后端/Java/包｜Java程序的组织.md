> 第一章提到过，Java程序编写在`.java`文件中，称为源文件；第二章介绍了Java是由一个个类组成的。这一章主要介绍他们之间的关系、以及构成Java程序的多个类如何存放。

## 源文件、类、主类、包

`.java`源文件，是Java程序最基本的编译单元，将一个个代码文件编译为对应的`.class`文件后执行。

类存放在源文件中，一个Java源文件内，只能有一个类型为public的公共类(也可以没有)，作为运行该源文件、通过该源文件启动程序时的的入口。这个类的名字，必须和源文件名相同。这个类称为该源文件的主类。

一个Java源文件可以有很多个类，但最多只能有一个主类。不过一般而言，多数时候，都习惯用一个类对应一个源文件，文件名和类名相同。但也有很多时候：几个类关系非常紧密、构成从属关系时、与其他类再无瓜葛，也会在一个源文件放多个类。

在类之上还有包，Java使用包将类组织在一个集合中，借助包来方便地组织代码，将自己的代码与别人提供的代码库、将负责某一个功能的代码与负责其他工作的代码分开管理。

## 包名

除了从语义上将不同功能的代码划分，使用包的另一主要原因是确保类名的唯一性。

不同的代码编写者可能建立了同样名字的类，毕竟他们各自的所实现的功能可能都包含某一类服务该功能的类，名字是很容易重复的。

将类放置在不同的包里，就能解决这一冲突。包起到了分隔命名空间的作用。

不过显然，包的名称，和包内类的名称，都需要保持唯一性。为了保证包名的绝对唯一性，通常用一个英特网域名的逆序形式作为包名。

- 从大到小：固定的前缀`com`➡️组织名➡️组织内细分名称➡️工程名➡️工程内细分功能模块名。
- 用英文句号`.`将每一层级分开。
- 类的名字首字母大写，而包名的首字母都小写。对于多个单词，一般也采用驼峰命名。
- 例如：`com.wml.demo`。

如果把类放在包里，用包名作为这个类的前缀，例如`com.wml.demo.Util`，这个名字就是类的**完全限定名**。

## 包的创建

- **与文件目录映射**

	Java中包的组织结构，和文件系统中目录的结构是一样的。

	包是通过文件夹来建立的，或者说文件夹为包的载体，一个文件夹就是一个包，文件夹内包含多个Java源文件，文件夹内这些源文件、源文件中的类都属于这个包。

	包名是多个层级用句号分隔组成的，每个层级对应一个文件夹，即每一层都相当于是一个包。

	也就是说包是可以嵌套的，每一层文件夹的名字，就是这一层级的名字。从根位置到当前位置，每一层文件夹名字组成了当前这个文件夹包的包名。

	包虽然可以嵌套，但嵌套的包之间不存在任何（从属）关系，它们各是各的层级，没有任何联系，不存在说某个包属于另一个包的说法。例如`java.util`与`java.util.jar`两个包毫无联系，每个包都是一个独立的类集合；也不存在访问权限上的从属，名称的访问权限只按照上一章访问权限修饰符中介绍的规则来划分。

- **声明包**

	上面只是必要条件，也就是说放在类对应目录下也不简单属于这个包，但如果属于这个包，就必须放在这个位置，因为Java查找类的时候是根据这个查找的。
	
	除了放在正确的位置，还要在源文件的第一行最开始，声明它所属的包，语法为`package 包名;`。
	
	如果没有这个语句，源文件里的类就属于一个默认的**无名包**。

## 包的导入——使用其他包中的类

前面访问权限修饰符介绍过，一个类可以使用它所属包中的所有其他类，以及其他包中的公共类。

在一个类中访问另一个包中的public类有两种方法：

1.使用该类的完全限定名，即`包名.类名`。

2.但这样比较繁琐，更简单常用的方式是使用import语句。

语法为：`import 包名.*;`。该语句表示导入这个包下的所有公共类，这之后可以直接使用相应类名。

- import语句必须放在源文件的一开始，在开始的位置导入所有需要的类，不能穿插别的代码。
- 前面提到过，以另一个包名为前缀的包，它们之间没有任何关系，导入也是同理，上面的语句只是导入这个包自己的类，并不会导入以该名字为前缀的其他包内的类。
- 还可以通过语句`import 包名.类名;`，明确地只导入专门的类。
- 几个包导入的类中存在同名类时：
	- 在类名前面加上包名来使用，通过类的完全限定名来区分。
	- 也可以通过在导入的类名后面加`as 别名`，通过使用别名区分。

>前面讲到过，Java源文件只能有一个和文件名相同的公共类，而导入其他包的类的时候也只能导入公共类，所以非常巧，导入类时的这个名字，恰好也是源文件的名字，像是导入了这个源文件一样（但其实不是，这个文件内的其他非公共类并不能使用）。


**静态导入：**
除了上面三种方式，还有一种import语句，用于导入某个类的全部静态成员，语法为：`import static 包名.类名.*;`，这样可以导入这个类下的全部公共成员，能够直接使用它们的名字。
<br>除此之外，也可以专门导入某个特定的静态成员，语法和前面相似。

## classpath 类路径（其实叫包路径更贴切）

**基本概念：**

上面讲的是通过包来唯一确定类、如何在包中定位类，那么要怎么定位包呢？

通过指定类路径，来告诉JVM，运行一个Java程序时，在什么位置找到包含着类的包。

**指定classpath的方式有两种：**

- 通过java或javac命令运行Java程序时，通过-classpath选项来指定类路径，语法为在命令后添加选项`-classpath 类路径`。
- 在操作系统设置全局变量。全局变量的概念第一章有提到过，具体设置方式Window系统和UNIX系统有差异，可自行搜索。

>一般采用后者，为所有Java程序，设定一个通用的、永久不变的classpath不是一个好的做法，因为人们经常会忘记全局设置。
>
>在每次调用命令时，通过选项设置classpath更优。但这样做比较麻烦，最佳实践是：将每个需要设置类路径的Java程序的那个很长的编译、运行指令，存放在一个shell脚本或者批处理文件中，每次直接运行这个脚本。

**寻找某个类的过程：**

当你编译或运行Java程序时，如果是Java API提供的类，则不需要任何classpath就能直接使用；
<br>如果在运行命令时指定类classpath，就会按照你指定的路径挨个寻找包、寻找包中的匹配名字的类；
<br>如果没有指定选择，则会去系统全局变量中找，按照全局变量配置的classpath来搜寻类。

Java开发环境在寻找类时，总会先去java.lang寻找。这个包是默认导入，默认导入到了所有源文件，无需导入可以直接使用。然后再去根据你所声明的导入，按照上面的规则去搜索类。

**完全限定类名必须唯一：**

根据classpath搜索类时，会在每一个路径下，都按照包路径去查找一遍，尽管在某个路径下已经找到了。如果找到一个以上的类，就会报错，因为完全限定类名必须为一。不能存在两个一样的包装着一样的类。

**classpath的格式/语法：**

- 类路径可以有多个，Windows环境中用分号`;`分隔，UNIX环境用冒号`:`
- 句点`.`表示的是当前所在位置/目录。它可以单独作为路径加入classpath表示运行指令时所在的当前路径，例如：`/home/userX/dir1:.:/home/userY/dir3`，这里面包含了三个路径，中间那个就是表示当前位置的相对路径。当前目录是需要显式指定的：
	- 如果进行编译指令，编译器会自动把当前执行命令时的所在目录也纳入类路径，自动去当前目录下搜索包。
	- 但对于运行Java程序的指令，如果你没有显式指定当前目录，又使用了当前目录下某个包的类，Java解释器是不会自动搜寻的，会因找不到这个类而报错。

classpath所指定的是包树状结构的基目录：即类路径是存包的，而不是包的根目录，包的根目录是放在classpath这个路径对应的目录里面的。

