# 面向对象-继承

继承的基本思想就是在已有类的基础上创建新的类，复用这些类的成员，添加新的方法和字段，使新类能够适应新的情况。

具体例如经典游戏PvZ，植物是一类，僵尸是一类，所有的植物和僵尸，都具备一些最基础的特性：都存在一个生命值、具有攻击行为、需要阳光购买......那么在进行设计时，就可以先创建一个通用的Plant类，具备属性hp、firepower、price等属性，具备attack等方法，在这个类的基础上，再构建一系列具体的类，从而将重复的代码复用。例如植物向日葵就还会具备产生阳光的方法、不同植物的攻击力firepower不同、不同植物调用attack产生的动画特效不同......

在这种继承关系中，被继承的这个类，称为超类superclass、基类base class、父类parent class，继承别的类的类称为子类subclass、派生类derived class、孩子类child class。它们之间的关系为“是(is-a)”的关系。

## 定义子类/继承

通过关键字`extends`关键字，基于某个类，以他为父类，定义他的子类。

只能专门定义子类，被继承的这个类自动成为这一关系中的父类，不能定义某个子类的父类，先有父后有子不能反过来。

定义子类就是在常规的定义类语法的基础上，在类名后加上`extends 父类名`。例如：

```Java
Public class Manager entends Employee {
	...
}
```
花括号里面的内容和定义类相比，并没有什么特别之处。

这样定义的子类，能够继承父类的成员。这包括静态成员，但静态代码块、构造代码块都没办法被继承，它们算不上类的成员。

- 正如静态成员的定义，他是属于类本身的，所以哪怕静态属性被继承了，在子类这用的还是父类的，它们共用的是同一块存储空间。子类对其所继承的静态属性的改动，会反映在父类上。

尽管没有特别声明父类成员，但可以在子类的对象上使用父类中的成员，访问方式和前面章节提到的访问类成员的方式完全一样。这样一来就只需要指出子类与超类的不同之处。

设计类的时候将最一般的功能放在超类中，将更特殊的功能放在子类中。

## 所继承内容的可见性——受保护访问

前面章节介绍访问权限修饰符的时候已经介绍过，这里重提作简单回顾：通过protected关键字，将成员的访问权限控制在包内和继承链内。

访问权限修饰符只是控制能否访问，该继承还是要继承的，也就是说你用private声明的成员和用protected声明的成员，都会被子类继承，存在于子类对象内，只不过private声明的成员没办法通过子类访问而已。这些私有成员仍然是子类型对象的一部分，实例化的时候JVM也需要为这些私有属性分配内存空间、初始化值（具体如何做见后文“子类构造器”部分），如果是希望阻止成员被继承，要使用后文介绍的`final`关键字。

## 覆盖方法

除了在子类中添加父类没有的属性、方法，有些父类的方法对子类不见得适用，或者子类需要让这些方法执行的内容更具体。

通过在子类中定义和父类方法签名一样的方法，来将父类的这个方法覆盖(override)掉，这样在对子类对象调用这个方法时，用的就是子类的。

---

**覆盖时调用父类同名方法：**

Java还提供了关键字`super`让你能够在覆盖方法内调用父类原本的方法，即在执行原方法流程的基础上增加内容，定义新的覆盖方法。通过`super.方法名`来使用。

super并不是像this一样对某个对象的引用，它只是一个指示编译器要调用超类方法的一个特殊关键字，不能通过super访问父类属性、也不能将super赋值给某个对象变量。

---

**限制：**

- 可见性方面的限制：
	- 覆盖也是访问的一种，所以对于那些private权限的方法，虽然继承了，但是不能覆盖，不能够出现方法签名和父类private权限方法一样的方法。
	- 覆盖时，子类方法的可见性不能低于父类的，要么访问权限比父方法大，要么维持一致。
- 返回值方面的限制：覆盖/和父类方法签名相同时，方法的类型，即返回值的类型，必须属于父类方法返回值类型。即返回值类型一致或为子类。
- 抛出异常方面的限制：和上一条类似，覆盖/和父类方法签名相同时，如果是抛出编译时异常，不能抛出比被覆盖方法更多的编译时异常，即抛出的异常只能是父类对应方法所抛出的某个异常的子类或为同一个类，也可以不抛出异常；运行时异常没有这样的限制。【有关什么是异常见后面的章节。
- 方法类型方面的限制：被覆盖的方法必须为实例方法。
	- 静态成员它们都是属于类的，虽然能被继承，但没办法被覆盖，不过你依然可以在子类定义一个方法签名和父类一样的方法，不过这样做法的实际效果是子类的静态方法隐藏了父类的，而非覆盖，只是效果上像。它们具体的区别主要体现在向上转型上，这一点在下文介绍继承链上类的类型转换时会详细展开讲。
	- 并且，父类和子类不能出现两个同样签名的方法，一个带static一个不带、一个是实例方法一个是类方法，这会导致报错。


## 覆盖属性

属性也是可以被覆盖的，可以在子类中定义与父类名称相同的属性，以此来覆盖掉改名称在父类中的各种情形：默认值、类型、是否为常量。

覆盖属性也有类似前文“覆盖方法限制”中第1、4条的限制。

## 子类构造器

>构造方法本质也是方法，也能被继承，不过父类和子类属性都不一样，子类是以一种不同于上面的形式继承的构造函数。

子类的构造函数中可以通过`super`关键字调用父类的构造函数，形式很类似用this关键字调用当前类的构造函数，直接使用super，把它当成方法名即可。

- 子类构造器内如果不调用父类，编译器就会自动给它在一开始添加一个父类的无参构造器调用：`super();`，要是父类没有，就会报错。
- 子类构造器内调用父构造器，除了复用代码，快速初始化一些父类的属性之外，还有一个必须存在的理由：父类中private权限的属性子类只是能继承，但不能在子类内访问，需要通过父类方法访问，这就必须通过父类构造器初始化。

## 阻止继承

当设计者不希望某个类被扩展、被其他的类继承时，使用`final`关键字。

- 在定义类时，class关键字前加final，就可以使这个类无法被继承。

- 定义类方法时，function关键字前加final，就可以使这个方法无法被覆盖重写。

- 类属性的继承无法被阻止，类的所有属性一定会被它的子类所继承。
	>属性加final字段是用来声明其为常量的。