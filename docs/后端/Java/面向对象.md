# 面向对象
> 面向对象与面向过程：
> 
> 传统的程序设计通过设计一系列过程来求解问题，Pascal语言语言的设计者Niklaus Wirth所提出的“程序=算法+数据结构”是这种思想的体现，算法是第一位的，数据结构是第二位，先确定如何操作、处理数据，再决定组织数据的结构。这种组织程序方式的典型就是C语言，由一个个函数调用组成。
>
>而OOP（object-oriented programming）调换了这个次序，程序由对象组成，将数据放在第一位，然后再考虑操作数据的算法。这一思想的典型是Java。
>
>对一些规模较小的问题而言，面向过程比较快捷方便，是理想选择。面向对象更适合解决规模较大的问题，这种更加结构化的代码能使程序更易读、更易维护、更快的发现问题。
>
>不过现在许多语言为了其灵活性、表达能力，同时支持多种编程范式，供开发者根据需要灵活使用，例如C++、Javascript，既可以编写面向对象风格的程序，也可以面向过程；
><br>除此之外，编程范式也不止这两种，还有很多其他的编程范式：泛型、函数式(它和面向过程不是一个东西)、事件驱动等。

## 基本概念
### 类与对象

上一章介绍数据类型时只介绍了基本类型，Java数据类型的另一大类就是**引用类型**，就是类，也可以叫封装类型、自定义类型、复合数据类型。

**两者关系**：

- 类是构建对象的模板，对象由类创建，其数据类型上属于某个类。
- 你可以理解为前面基本类型中，类型与变量的关系。对象就是这种类型具体的值、承载具体内容，而类则标识这到底是怎样一种数据，标识其类别。

由类构造对象的过程，成为类的**实例化**，创建出来的对象成为这个类的**实例**。【所以对象和实例说的基本是一回事，只不过语境不同

类，或者说对象，他们内部主要由两部分成员**构成**：属性和方法。

- **属性**用来存储这个对象的一些**状态**、数据，可以是基本类型、也可以是类。
	
	类中声明了这些数据的类型，根据类创建的对象存储具体值。
	
	也叫**字段**field。
	
	其实就是变量(你可以这么理解，但不能反着说，变量更广义一些，比如函数中定义的一些数据，这种才是真正的变量)。
- **方法**就是这个类的**行为**，标识着它可以做些什么，这是一段可执行程序，是个过程。
	
	其实就是函数，如果你学过C语言之类的，你把它理解成函数就好了，这俩是一个东西，Java中没有独立存在的函数，都是依附于类，以方法的形式作为其成员。

**引用：**

不同于上一章基本类型里提到的变量，当变量为对象时，变量所标识的东西，或者说变量所指向的内存位置存储的数据，不是这个对象的数据，而是一个内存地址。这个地址指向对象数据在内存中真正存储的位置。我们将这个内存地址/变量，称为该对象的引用。
	
使用这个对象时使用的其实是这个引用，程序会根据引用找到这个对象的实际位置，通过引用间接访问对象成员。
	
也就是说，对象的值并不是这个对象实际的内容/数据，对象这种特殊变量的值是个引用(你也可以理解成内存地址)。
	
- 对于基本类型的变量，创建一个变量a，用字面量给他初始化一个值后，再创建另一个变量b，将a的值赋值给b，其实际效果是在内存中开辟了两个区域，分别存储a、b两个变量，虽然他们的值一样，但他们各是各的；
	
- 对于引用类型的变量，创建一个对象a，给他一个初始值后，再创建另一个对象b，将a的值赋值给b，其实际效果是内存中开辟了两个区域，分别存储对象a、b的引用，两者依旧各是各的，只是值一样。但由于他们的值是引用类型，实际指向的对象是一个对象，这个过程中，只开辟了一个区域，对象的具体内容/数据始终都是创建a时的那一份。将a初始化赋值给b的过程中，并没有新的实例被创建，只是新创建了一个对象类型的变量。操作变更对象a的属性后，访问对象b的该属性，拿到值是变更后的。
	
即通过赋值语法复制一个引用类型的变量，实际只是复制了对象的引用，对象本身并没有复制，如果希望复制创建一个全新的对象，需要用到一些拷贝对象的途径。这一点后面再介绍。
	
这一段抽象的概念或许有些难以理解，需要你结合后面对象相关的具体语法，以及如何拷贝对象来理解。这里对于初学者难以理解的点在于把握“对象”这一词汇具备双重含义：
	
1. 在内存中存储着的、实际的对象内容、数据。
2. 一种特殊的变量，值为指向一个类实例的引用/地址。但在使用这一词时却不会区分，像在介绍引用这一概念之前，前文提到的对象指的都是第一重含义，即对象的具体内容。所以理解这件事儿的关键就在于结合语境判断导致指的是实际内容，还是引用。
	
对于编译器、或者说Java语法规范而言，使用对象变量(的成员)时使用的是其背后实际对象的值；而在变量赋值、作为函数参数值传递(其实这本质也是赋值)这类将其单纯视为变量，使用其本身值的时候，使用的是引用。

> Java这一点和C++有很大的不同，C++里引用(/指针)就是引用，对象就是对象，对象类型的变量指的永远都是实际对象的数据，其引用/地址则是该类型的指针，想通过其指针/引用访问对象内容要先通过专门的解引用运算符拿到实际指向的内容才行。
> 
> 而Java没把他们拆开，两者是一回事儿，要结合具体的用法来判断。对象类型的变量到底指什么，取决于以何种方式使用它。

**总结：**

类就是类型，和前面基本类型int、char这些一样，只不过是一种自定义的类型。

对象就是类型为这种自定义类的数据。

对象变量，或者说类类型的变量的值不是对象本身，而是指向对象的引用，可以类比前面基本类型的数值、字面量。

对象具有行为和状态。

- 行为通过可调用的方法/函数定义，代表了这类对象的能力，可以做什么、完成什么操作。
	<br>一个类的所有对象实例有着同样的行为，他们的方法都是共用的，都是来自于创建他们的类，而不像状态，每个对象都有一份自己的存着；
- 状态保存着描述对象当前状态的信息。

对象的标识/引用：状态无法完全描述一个对象，状态值完全一样的两个对象不见的相同，这就像两个int类型的变量a和b，尽管他们的值都是3例如，但他们各是各的，只是值一样。每个对象都有一个唯一标识，这个标识就是对象的引用，它们指向不同的对象。

### 预定义类
类又可以分成两种，一种是开发人员自行根据需要编写的**自定义类**，一种是由Java预先提供，成为了语言标准、语法的一部分，为**预定义类**，这些预定义类通常比基本类型复杂，需要用类实现，用于解决某类普遍问题，例如处理时间的Date和LocalDate、用于数学计算的Math、字符串String、数组Array、枚举Enum、处理文件读写的File类、用于网络编程的Socket类等等。

预定义类在实现上还可以再分成两种，

- 一种在实现上和你自己定义的类没有任何区别，完全用Java语法实现，你能看得到他的实现、构成，就是Java替你封装好的一些工具类，方便你直接使用。例如Java的各种集合类，他封装了一系列典型的数据结构和算法在里面，方便你直接基于此来组织数据；
- 还有一部分预定义类，虽然他在使用上，和普通的类没有任何区别，类语法规定怎样使用，他就怎样使用。但是你看不到他的内部构成，或者说它底层根本就不是通过Java实现的，它只是以类的形式向你提供一些Java语言的某种能力，例如处理网络请求、文件读写。这种也不可能通过Java语言本身实现，这种类是直接被编译器、JVM原生支持，以更底层的方式实现的，实现级别不在Java。

## 基本语法
前面一节是从概念上，比较抽象地介绍类，这一节介绍编写、使用一个类所需的最基本语法。

### **类的定义**
类的最简单定义形式如下

```Java
class ClassName{
	field1
	field2
	...
	constructor1
	constructor2
	...
	method1
	method2
	...
}
```
这里面ClassName的位置是类的名字，就像int、float一样，类名的命名规则遵照前面提到的标识符命名方法。除此之外Java规定所有的类名第一个字符必须为大写字母开头。类名使用驼峰命名法（这一点不是语法规范的强制要求，但几乎没有例外）。

类名前面的`class`是关键字，标识这里是一个类的定义/声明。

field处就是类的字段/属性/状态，定义类属性的方式，和前面提到的定义变量的语句一样。

constructor的位置是类的构造器/构造函数/构造方法，他用于创建一个类的对象，指示遵照何种规则实例化、如何创建该类型对象。有关构造函数的部分后文将详细展开。

method的位置就是类的方法/函数。

这三者的顺序是任意的，先写谁、混着写，都无所谓，语法没有做任何要求，只是一般会这样写，比较符合逻辑、易读。

### **类的实例化/对象的创建**
这一过程你可以类比创建某一基本类型的变量。

```Java
ClassName classNameObj = new ClassName();
```
这和基本类型的语法基本是一致的，先声明变量类型，然后是对象名称，命名规则遵循前面提到的标识符命名，不同的是初始化时不能像基本类型那样直接给个字面量，要以构造函数的形式创建一个对象。

`new`关键字+`类名()`的形式表示创建一个该类型的对象，通过这种方式调用构造函数，在调用处返回创造出的对象引用。最终用过赋值语句将对象引用赋值给对象。

同样的，像前面基本类型提到的诸多关于变量的操作这里都是同理：

```Java
//只声明不初始化，声明创建多个对象
ClassName classNameObj1, classNameObj2；
//声明之后再初始化、赋值
classNameObj1 = new className();
//赋值，上一种是创建一个对象赋值，类比基本类型的字面量赋值；
//也可以拿对象给另一个对象赋值，赋值后它们的引用相同，指向同一个对象
classNameObj2 = classNameObj1；
```
这里展示的是最简化情形，让你先知道对象是怎么被创建出来的。实际上对象的创建不止这一种方法，通过new关键字创建对象也有着更复杂的情形，这些会在介绍完方法后，在构造器一节集中介绍。

### **对象(成员)的使用**
通过点操作符`.`访问调用对象的成员。

```Java
//获取、使用对象属性的几个例子
classNameObj.field1;
int someName = classNameObj.field1;
//修改对象属性的几个例子
classNameObj.field1 = 2 * 3 - 1;
classNameObj1.field1 = classNameObj2.field1;
//调用对象方法
classNameObj.method1();
```
### 方法
>有些语言叫函数，这里不作区分，将它们视为一回事儿。

>函数这个概念最早你应当是在数学中接触的：接收几个自变量，按照一定的规则，对变量运算，最后得到函数的值。数学中的函数强调的是一个数值集合于另一个集合的一种对应关系，从函数本身而言，是一种计算规则。
>
>编程中的函数也有这层意思，并且形式也和数学中的函数十分相似。但除此求值之外，编程中的函数还强调过程，函数除了最后返回一个值，函数的调用执行中，除了计算求出返回值，还可以存在很多不是求值、和计算无关的过程，它们只是单纯的执行某个操作，例如打开一个文件、发送一个网络请求、调用另一个函数、创建变量等等。
>
>编程中的函数还描述一段可执行过程，会产生一些副作用。

接收若干个参数、执行一段过程、返回一个结果值。

```java
TypeName fucntionName(Param1Type param1, Param2Type param2, ...){
	<do something>
	return <value>;
}
```
functionName就是函数的名字，标识这个函数，命名遵循前面的标识符命名。

后面圆括号里的是函数的参数列表，有若干个，表示这个函数执行需要的上下文/数据。参数需要在前面声明类型，多个参数用逗号分隔。
<br>函数体内可以根据名字拿到这些参数。
<br>这些参数本质就是变量，是局部变量，和函数内声明定义的那种局部变量没什么区别，只能在局部作用域内访问到。

花括号里是函数体，定义函数的执行过程，可以是任意语句：流程控制、(局部)变量创建、其他函数调用等等。

关键字`return`标志着函数执行的结束，函数只要执行到return语句，不管后面还有什么内容，都会终止，返回结果。返回语句中value处可以是个值，也可以是个能求到值的表达式，总之最终得能得到一个用来返回的值。

一开头的TypeName就是这个函数的类型，确切的说是函数返回值类型，即函数最终会返回个什么类型的值。

函数可以什么都不返回，但Java是强类型语言，需要对这种返回类型进行标识，使用关键字`void`，这是一个特殊的类型，表示函数什么也不返回，只是执行一个过程。将void放在TypeName处。
<br>显然void类型函数，返回语句里就没有值，直接为`return;`。
<br>函数可以没有return语句，从头执行到尾自动就结束了，等效于`return;`什么都不返回。
<br>void函数既然没有返回值，这种函数的调用，就没办法用于需要值的位置、求值表达式中，因为他都没有值，这种写法无法通过类型检查，会导致编译器报错。

方法通过操作符`()`调用，即现通过其所属的对象用点操作符访问到它，然后在后面接小括号表示对方法的调用，形如：`objName.methodName();`。

调用方法所需的参数写在括号内传入，有多个参数时参数顺序和声明方法是参数列表中的顺序一致，这个参数可以是任何能得到值的东西：字面量/直接的值、变量、求值表达式、对另一个能返回值的函数的调用。
<br>方法声明时括号里的那个参数列表也称形式参数，简称形参；调用时括号里传入的这个参数称实际参数，简称实参。
>不同于C++等语言，Java方法的参数不支持默认值，也就是说这个方法声明时参数列表里的参数有几个，调用时就要按照顺序，依次提供对应类型的参数值。

**隐式参数与显式参数**

方法名后面括号里的，在调用时传入的，是显式参数。

方法是属于某一个类的，当我们通过对象调用一个方法时，方法可以访问到调用它的对象成员，这些是隐式参数。即在方法内可以直接使用其所属的类的所有成员(属性和方法)。

这带来一个显而易见的问题，如果某个显示参数的名字，和方法所属类中的某个属性名字重名了，该怎么办？Java语法确实允许这样的命名。

所以不光为了使语义更加明显，与方法内普通的局部变量有所区别；更为了不产生歧义，与显示参数有所区分。通过`this`关键字访问隐式参数。
<br>this在方法中使用，用于指向正在调用方法的对象，即this就是调用对象本身。
<br>和访问对象成员的方式一样，this自引用就是对象，后面接点操作符`.`，接要访问的成员。

**方法(显式)参数的实质/函数参数的传递方式**

调用方法时，将参数传递给方法，方法内使用这些参数的本质是什么？这里先介绍几个术语：**按值调用**(call by value)表示方法接收的是调用者/调用处传递的值本身；**按引用调用**(call by reference)表示方法接收的是调用者提供的变量(地址)；按名调用(call by name)，一个古老程序设计语言Algol用的是这种方式，不展开介绍。

按值调用的本质，相当于在函数创建时，函数无法访问到实际传递的那个实参，函数的参数只是按照你声明的名字创建的一个局部变量，拷贝了实参的值。函数内对这个参数值的修改，并不会影响到调用函数时作为参数传入的那个变量。

结合前面学过的语法，你会发现，如果只有按值调用这一种方式，如果方法希望和外界产生某种交互，确切的说是方法希望更改某些值时，只有通过隐式参数更改调用它的对象内部成员的值这一种途径。但有时候人们希望函数的手能伸的再长一些，可以更改任意从显示参数处传入的值。这就是按引用调用的作用：按引用调用将变量的引用地址传入，在函数内通过这个地址访问到变量本身，函数内外共用同一个变量，对参数的修改会直接反映到传入的实参上。这一语法被C++这类的语言所支持。

Java只支持按值调用，也就是说方法得到的所有参数值都只是一个副本，方法不能修改传递给它的任何参数变量的内容。

**递归**

在一个方法内调用方法本身。在某种条件下循环进入调用方法自身的分支，另外的条件下进入别的分支，我们将这种方法循环调用自身的程序结构称为递归。

**方法重载 overloading**

对于某个方法调用时，我们希望视具体情形传入不同的参数列表，虽然传参情形不一样，但本质做的都是一件事儿，对应的方法内容可能只有略微调整。比如有时候希望在带参数的方法之外，提供一种不传递任何参数时的默认行为。重载就是用于解决这一类需求语法。
>对这种情形，其实依旧可以通过一个确定的参数列表，然后在函数体内通过条件语句判断参数的值，甚至通过一些额外的冗余参数标识来实现，通过这种方式做出区分、对应函数的不同行为。但这样写语义不够明确，并且会产生许多冗余代码，降低可读性性。Java通过重载这一特性从语法层面以更简洁的方式解决这类问题。

重载是指多个方法有相同的名字，但参数列表不同。当调用方法时，编译器会自动根据传入的参数，匹配到对应的方法调用执行。

>名字相同说明它们做的是同一件事，不同的参数列表则是针对具体情形作出的细微变化。

>这里所说的参数列表，确切说指的是参数列表中各参数类型组成的有序类型列表，跟参数名字没关系。
><br>参数名说白了只是一个给函数内部看、区分各个参数的符号，更侧重逻辑、语义方面的作用，就语法、编译器而言，两个参数列表中参数的类型、顺序一致，那在重载、签名这个语境下，他们就没有区别，是一样的。

**签名signature:** 方法的名称与参数列表构成了方法签名，用于唯一标识、区分、完整描述一个方法。

方法名直观标识了方法的用途，决定了大基调，而参数列表的不同决定了方法该用途下的具体执行细节。

而返回值是方法的结果，并不能标识方法的唯一性，也就是说不能有两个名字和参数相同，但返回值类型不同的方法，这属于同一个方法的重复定义。

可以在一个方法内，调用该方法其他签名的重载。

### 访问权限修饰符

在介绍访问权限之前，为了解为何要这样设计，我们现在理论的角度，讨论**封装**的优点：
<br>封装指的就是他的字面意思：将类的一些实现细节、内部结构对外封闭起来，不允许外界访问、修改。确切地说是不对外暴露，外界不知其存在。我们把这种结构称作为外部透明。
<br>（这种说法和平常语言习惯不符：我们平常说透明，指的是具体的事物本身和我们之间隔了一层透明的玻璃，没隔不透明的东西，具体的事物被看光了；计算机术语里的透明是说这个具体东西是透明的，外界观测感知不到）

具体例如，最简单的封装，就是对类的某些成员属性，我们通过访问权限修饰符限制，限制为只有类自己的方法能访问，外界使用这个对象时，无法通过点操作符拿到这个属性，只能通过专门的方法来读取、修改。这样做有着诸多的好处：

1. 我们将要修改、访问的这个值变成了一个抽象的概念。
	<br>当某一天由于其他地方的牵连，导致这个属性名称不得不改的时候，如果不做封装任由外界直接获取，这就意味着这个属性的所有调用处都要改名字，
	<br>当程序的规模大到一定程度，首先肯定是麻烦，其次是可能有遗漏，把该改的漏掉了，把不该改的同名的其他什么东西给改掉了。
	<br>而如果封装，我们就最大程度地将未来可能的变化限制在了自己写的这个类内部，名字变动的时候直接改这个方法实现，而所有方法调用处都不需要动。
	<br>进一步地，除了以这种方式兼容旧代码，还可以将这个方法约定废弃，新写一个起同样作用的方法用以匹配属性的变化，再次之后代码对该属性的访问全用新方法。从而逐步替换淘汰掉旧的。
2. 便于在修改属性值时做一些处理。
	<br>如果这个属性我们只希望被设置成特定取值范围的值，通过这种封装，可以在专门充作修改器的方法中进行校验；
	<br>再比如还是“1”中的情景下，属性名称变更后，我们希望进行一些新旧数据之间的转换处理，抑或是本身就需要在设置数据值之前进行预处理，使用这样的封装就十分便利。
3. 容易追踪变化与错误，类的设计不易遭到外界破坏。
	<br>如果将属性对外公开，直接从对象上访问，当这个属性被以意料之外的方式，或者说被以导致错误的方式使用、修改时，难以定位产生错误的位置。而如果使用专门的方法，只需要调试这个方法，就能更容易的发现、排查问题。

在上面这个情景中，将属性对外封装起来，用专门的方法进行读写时，专门用于读取某个属性的方法称作**访问器**，专门用于修改的方法称为**修改器**。也可以叫getter和setter。

通过这种封装思想的最简单实践情形我们可以看到：
<br>借助权限修饰符进行封装，能够使得代码之间尽可能的各司其职，不依赖对方；使得代码整体的结构更加干净，整齐。从而使程序更易维护、更可靠。
<br>同时这种权限修饰符也兼具语义作用，让程序的目的一目了然，增强可读性。

---

>访问修饰符的应用场景设计到了很多目前为止还没有介绍到的语法，不理解是正常的，知道有哪几种权限以及他们的差异、用法即可。对于不懂的概念看一眼就好了，等后面介绍到你就明白了。

访问修饰符可以用在除局部变量以外的绝大多数标识符上，用来限制对应名称的可访问性。
<br>都有：类、类的成员（属性、方法、构造方法、静态成员，只要是成员就都可以）、接口。

**public：**这个是最大的，哪儿都可以访问到，完全对外公开。（不过如果是别的包的名称，要先把这个包导入进来，毕竟包都没有的话连源文件都找不到。）

**protected：**主要用于把访问权限限定在继承链内，即只有类和它的子类能访问到（同样的，子类和基类不在一个包时要先导入包）；除此之外，包内的所有位置也都能访问到。也就是说这个修饰符你可以理解成，最多只将成员暴露给与当前类的实现、运行时有关的需要密切协作的类，继承的类自不必说，而包内的类肯定是实现同一个功能模块才会把他们放在一个包里（语法没有这样要求，只是一般这么做）。
<br>可以看到，它侧重于限制几个类之间继承时，权限的传播的。所以这个关键字只能限制类的成员，不能用在类和接口上。

**default：**什么都不写的默认值就是default。